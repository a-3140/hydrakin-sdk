{"version":3,"file":"sdk.cjs.production.min.js","sources":["../src/core/storage.ts","../src/apollo/client.ts","../node_modules/regenerator-runtime/runtime.js","../src/apollo/fragments.ts","../src/apollo/mutations.ts","../src/constants.ts","../src/apollo/queries.ts","../src/core/auth.ts","../src/react/components/SaleorProvider.tsx","../src/react/helpers/hookFactory.ts","../src/react/hooks/auth.ts","../src/react/hooks/user.ts","../src/react/hooks/saleorConfig.ts","../src/core/createSaleorClient.ts","../src/core/constants.ts","../src/core/user.ts","../src/core/state.ts","../src/react/helpers/hookStateFactory.ts"],"sourcesContent":["import { LOCAL_STORAGE_EXISTS } from \"../constants\";\nimport { SALEOR_AUTH_PLUGIN_ID, SALEOR_CSRF_TOKEN } from \"./constants\";\n\nexport let storage: {\n  setAuthPluginId: (method: string | null) => void;\n  getAuthPluginId: () => string | null;\n  setAccessToken: (token: string | null) => void;\n  getAccessToken: () => string | null;\n  setCSRFToken: (token: string | null) => void;\n  getCSRFToken: () => string | null;\n  setTokens: (tokens: {\n    accessToken: string | null;\n    csrfToken: string | null;\n  }) => void;\n  clear: () => void;\n};\n\nexport const createStorage = (autologinEnabled: boolean): void => {\n  let authPluginId: string | null = LOCAL_STORAGE_EXISTS\n    ? localStorage.getItem(SALEOR_AUTH_PLUGIN_ID)\n    : null;\n  let accessToken: string | null = null;\n  let csrfToken: string | null =\n    autologinEnabled && LOCAL_STORAGE_EXISTS\n      ? localStorage.getItem(SALEOR_CSRF_TOKEN)\n      : null;\n\n  const setAuthPluginId = (pluginId: string | null): void => {\n    if (LOCAL_STORAGE_EXISTS) {\n      if (pluginId) {\n        localStorage.setItem(SALEOR_AUTH_PLUGIN_ID, pluginId);\n      } else {\n        localStorage.removeItem(SALEOR_AUTH_PLUGIN_ID);\n      }\n    }\n\n    authPluginId = pluginId;\n  };\n\n  const setCSRFToken = (token: string | null): void => {\n    if (autologinEnabled && LOCAL_STORAGE_EXISTS) {\n      if (token) {\n        localStorage.setItem(SALEOR_CSRF_TOKEN, token);\n      } else {\n        localStorage.removeItem(SALEOR_CSRF_TOKEN);\n      }\n    }\n\n    csrfToken = token;\n  };\n  const setAccessToken = (token: string | null): void => {\n    accessToken = token;\n  };\n\n  const getAuthPluginId = (): string | null => authPluginId;\n  const getAccessToken = (): string | null => accessToken;\n  const getCSRFToken = (): string | null => csrfToken;\n\n  const setTokens = ({\n    accessToken,\n    csrfToken,\n  }: {\n    accessToken: string | null;\n    csrfToken: string | null;\n  }): void => {\n    setAccessToken(accessToken);\n    setCSRFToken(csrfToken);\n  };\n\n  const clear = (): void => {\n    setAuthPluginId(null);\n    setAccessToken(null);\n    setCSRFToken(null);\n  };\n\n  storage = {\n    setAuthPluginId,\n    setAccessToken,\n    setCSRFToken,\n    getAuthPluginId,\n    getAccessToken,\n    getCSRFToken,\n    setTokens,\n    clear,\n  };\n};\n","import {\n  ApolloClient,\n  createHttpLink,\n  InMemoryCache,\n  NormalizedCacheObject,\n  Reference,\n  FetchResult,\n} from \"@apollo/client\";\nimport fetch from \"cross-fetch\";\nimport jwtDecode from \"jwt-decode\";\n\nimport { TypedTypePolicies } from \"./apollo-helpers\";\nimport { JWTToken } from \"../core\";\nimport { AuthSDK, auth } from \"../core/auth\";\nimport { storage } from \"../core/storage\";\nimport { ExternalRefreshMutation, RefreshTokenMutation } from \"./types\";\n\nlet client: ApolloClient<NormalizedCacheObject>;\nlet authClient: AuthSDK;\nlet refreshPromise:\n  | ReturnType<AuthSDK[\"refreshToken\"]>\n  | ReturnType<AuthSDK[\"refreshExternalToken\"]>\n  | null = null;\nconst isTokenRefreshExternal = (\n  result: RefreshTokenMutation | ExternalRefreshMutation\n): result is ExternalRefreshMutation => \"externalRefresh\" in result;\n\nexport type FetchConfig = Partial<{\n  /**\n   * Enable auto token refreshing. Default to `true`.\n   */\n  autoTokenRefresh: boolean;\n  /**\n   * Set a value for skew between local time and token expiration date in\n   * seconds (only together with `autoTokenRefresh`). Defaults to `120`.\n   */\n  tokenRefreshTimeSkew: number;\n  /**\n   * Refresh token and retry the request when Saleor responds with `Unauthorized` error.\n   * Defaults to `true`.\n   */\n  refreshOnUnauthorized: boolean;\n}>;\n\nexport const createFetch = ({\n  autoTokenRefresh = true,\n  tokenRefreshTimeSkew = 120,\n  refreshOnUnauthorized = true,\n}: FetchConfig = {}) => async (\n  input: RequestInfo,\n  init: RequestInit = {}\n): Promise<Response> => {\n  if (!client) {\n    throw new Error(\n      \"Could not find Saleor's client instance. Did you forget to call createSaleorClient()?\"\n    );\n  }\n\n  let token = storage.getAccessToken();\n  const authPluginId = storage.getAuthPluginId();\n\n  try {\n    if (\n      [\"refreshToken\", \"externalRefresh\"].includes(\n        // INFO: Non-null assertion is enabled because the block is wrapped inside try/catch\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        JSON.parse(init.body!.toString()).operationName\n      )\n    ) {\n      return fetch(input, init);\n    }\n  } catch (e) {}\n\n  if (autoTokenRefresh && token) {\n    // auto refresh token before provided time skew (in seconds) until it expires\n    const expirationTime =\n      (jwtDecode<JWTToken>(token).exp - tokenRefreshTimeSkew) * 1000;\n\n    try {\n      if (refreshPromise) {\n        await refreshPromise;\n      } else if (Date.now() >= expirationTime) {\n        // refreshToken automatically updates token in storage\n        refreshPromise = authPluginId\n          ? authClient.refreshExternalToken()\n          : authClient.refreshToken();\n        await refreshPromise;\n      }\n    } catch (e) {\n    } finally {\n      refreshPromise = null;\n    }\n    token = storage.getAccessToken();\n  }\n\n  if (token) {\n    init.headers = {\n      ...init.headers,\n      \"authorization-bearer\": token,\n    };\n  }\n\n  if (refreshOnUnauthorized && token) {\n    const response = await fetch(input, init);\n    const data: FetchResult = await response.clone().json();\n    const isUnauthenticated = data?.errors?.some(\n      error => error.extensions?.exception.code === \"ExpiredSignatureError\"\n    );\n    let refreshTokenResponse: FetchResult<\n      RefreshTokenMutation | ExternalRefreshMutation,\n      Record<string, unknown>,\n      Record<string, unknown>\n    > | null = null;\n\n    if (isUnauthenticated) {\n      try {\n        if (refreshPromise) {\n          refreshTokenResponse = await refreshPromise;\n        } else {\n          refreshPromise = authPluginId\n            ? authClient.refreshExternalToken()\n            : authClient.refreshToken();\n          refreshTokenResponse = await refreshPromise;\n        }\n\n        if (\n          refreshTokenResponse.data &&\n          isTokenRefreshExternal(refreshTokenResponse.data)\n            ? refreshTokenResponse.data.externalRefresh?.token\n            : refreshTokenResponse.data?.tokenRefresh?.token\n        ) {\n          // check if mutation returns a valid token after refresh and retry the request\n          return createFetch({\n            autoTokenRefresh: false,\n            refreshOnUnauthorized: false,\n          })(input, init);\n        } else {\n          // after Saleor returns ExpiredSignatureError status and token refresh fails\n          // we log out the user and return the failed response\n          authClient.logout();\n        }\n      } catch (e) {\n      } finally {\n        refreshPromise = null;\n      }\n    }\n\n    return response;\n  }\n\n  return fetch(input, init);\n};\n\nconst getTypePolicies = (autologin: boolean): TypedTypePolicies => ({\n  Query: {\n    fields: {\n      authenticated: {\n        read(_, { readField, toReference }): boolean {\n          return !!readField(\n            \"id\",\n            toReference({\n              __typename: \"User\",\n            })\n          );\n        },\n      },\n      me: {\n        read(_, { toReference, canRead }): Reference | undefined | null {\n          const ref = toReference({\n            __typename: \"User\",\n          });\n\n          return canRead(ref) ? ref : null;\n        },\n      },\n      authenticating: {\n        read(\n          read = autologin && !!storage.getCSRFToken(),\n          { readField }\n        ): boolean {\n          if (readField(\"authenticated\")) {\n            return false;\n          }\n\n          return read;\n        },\n      },\n    },\n  },\n  User: {\n    /**\n     * IMPORTANT\n     * This works as long as we have 1 User cache object which is the current logged in User.\n     * If the client should ever fetch additional Users, this should be removed\n     * and the login methods (token create or verify) should be responsible for writing USER query cache manually.\n     */\n    keyFields: [],\n    fields: {\n      addresses: {\n        merge: false,\n      },\n    },\n  },\n});\n\nexport const createApolloClient = (\n  apiUrl: string,\n  autologin: boolean,\n  fetchOptions?: FetchConfig\n): ApolloClient<NormalizedCacheObject> => {\n  const httpLink = createHttpLink({\n    fetch: createFetch(fetchOptions),\n    uri: apiUrl,\n    credentials: \"include\",\n  });\n\n  const cache = new InMemoryCache({\n    typePolicies: getTypePolicies(autologin),\n  });\n\n  client = new ApolloClient({\n    cache,\n    link: httpLink,\n  });\n\n  /**\n   * Refreshing token code should stay under core/auth.ts To get this method available,\n   * we need to call \"auth()\" here. refreshToken mutation doesn't require channel, so it\n   * doesn't have to be populated with value.\n   */\n  authClient = auth({ apolloClient: client, channel: \"\" });\n\n  return client;\n};\n","/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar runtime = (function (exports) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  function define(obj, key, value) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n    return obj[key];\n  }\n  try {\n    // IE 8 has a broken Object.defineProperty that only works on DOM objects.\n    define({}, \"\");\n  } catch (err) {\n    define = function(obj, key, value) {\n      return obj[key] = value;\n    };\n  }\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  exports.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunction.displayName = define(\n    GeneratorFunctionPrototype,\n    toStringTagSymbol,\n    \"GeneratorFunction\"\n  );\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      define(prototype, method, function(arg) {\n        return this._invoke(method, arg);\n      });\n    });\n  }\n\n  exports.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  exports.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      define(genFun, toStringTagSymbol, \"GeneratorFunction\");\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  exports.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator, PromiseImpl) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return PromiseImpl.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return PromiseImpl.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function(error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new PromiseImpl(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n  exports.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n    if (PromiseImpl === void 0) PromiseImpl = Promise;\n\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList),\n      PromiseImpl\n    );\n\n    return exports.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        // Note: [\"return\"] must be used for ES3 parsing compatibility.\n        if (delegate.iterator[\"return\"]) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  define(Gp, toStringTagSymbol, \"Generator\");\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  Gp[iteratorSymbol] = function() {\n    return this;\n  };\n\n  Gp.toString = function() {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  exports.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  exports.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n\n  // Regardless of whether this script is executing as a CommonJS module\n  // or not, return the runtime object so that we can declare the variable\n  // regeneratorRuntime in the outer scope, which allows this module to be\n  // injected easily by `bin/regenerator --include-runtime script.js`.\n  return exports;\n\n}(\n  // If this script is executing as a CommonJS module, use module.exports\n  // as the regeneratorRuntime namespace. Otherwise create a new empty\n  // object. Either way, the resulting object will be used to initialize\n  // the regeneratorRuntime variable at the top of this file.\n  typeof module === \"object\" ? module.exports : {}\n));\n\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  // This module should not be running in strict mode, so the above\n  // assignment should always work unless something is misconfigured. Just\n  // in case runtime.js accidentally runs in strict mode, we can escape\n  // strict mode using a global Function call. This could conceivably fail\n  // if a Content Security Policy forbids using Function, but in that case\n  // the proper solution is to fix the accidental strict mode problem. If\n  // you've misconfigured your bundler to force strict mode and applied a\n  // CSP to forbid Function, and you're not willing to fix either of those\n  // problems, please detail your unique predicament in a GitHub issue.\n  Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n}\n","import { gql } from \"@apollo/client\";\n\nexport const accountErrorFragment = gql`\n  fragment AccountErrorFragment on AccountError {\n    code\n    field\n    message\n  }\n`;\n\nexport const addressFragment = gql`\n  fragment AddressFragment on Address {\n    id\n    firstName\n    lastName\n    companyName\n    streetAddress1\n    streetAddress2\n    city\n    cityArea\n    postalCode\n    country {\n      code\n      country\n    }\n    countryArea\n    phone\n    isDefaultBillingAddress\n    isDefaultShippingAddress\n  }\n`;\n\nexport const userBaseFragment = gql`\n  fragment UserBaseFragment on User {\n    id\n    email\n    firstName\n    lastName\n    isStaff\n    isSeller\n  }\n`;\n\nexport const userDetailsFragment = gql`\n  ${addressFragment}\n  ${userBaseFragment}\n  fragment UserDetailsFragment on User {\n    ...UserBaseFragment\n    metadata {\n      key\n      value\n    }\n    defaultShippingAddress {\n      ...AddressFragment\n    }\n    defaultBillingAddress {\n      ...AddressFragment\n    }\n    addresses {\n      ...AddressFragment\n    }\n  }\n`;\n","import { gql } from \"@apollo/client\";\n\nimport {\n  accountErrorFragment,\n  addressFragment,\n  userBaseFragment,\n  userDetailsFragment,\n} from \"./fragments\";\n\nexport const LOGIN_WITHOUT_DETAILS = gql`\n  ${accountErrorFragment}\n  ${userBaseFragment}\n  mutation loginWithoutDetails($email: String!, $password: String!) {\n    tokenCreate(email: $email, password: $password) {\n      csrfToken\n      token\n      errors {\n        ...AccountErrorFragment\n      }\n      user {\n        ...UserBaseFragment\n      }\n    }\n  }\n`;\n\nexport const LOGIN = gql`\n  ${accountErrorFragment}\n  ${userDetailsFragment}\n  mutation login($email: String!, $password: String!) {\n    tokenCreate(email: $email, password: $password) {\n      csrfToken\n      token\n      errors {\n        ...AccountErrorFragment\n      }\n      user {\n        ...UserDetailsFragment\n      }\n    }\n  }\n`;\n\nexport const REGISTER = gql`\n  ${accountErrorFragment}\n  mutation register($input: AccountRegisterInput!) {\n    accountRegister(input: $input) {\n      errors {\n        ...AccountErrorFragment\n      }\n      requiresConfirmation\n    }\n  }\n`;\n\nexport const REFRESH_TOKEN = gql`\n  ${accountErrorFragment}\n  mutation refreshToken($csrfToken: String!) {\n    tokenRefresh(csrfToken: $csrfToken) {\n      token\n      errors {\n        ...AccountErrorFragment\n      }\n    }\n  }\n`;\n\n// separate mutation so the request payload is minimal when user is not needed\n// used for initial authentication\nexport const REFRESH_TOKEN_WITH_USER = gql`\n  ${accountErrorFragment}\n  ${userDetailsFragment}\n  mutation refreshTokenWithUser($csrfToken: String!) {\n    tokenRefresh(csrfToken: $csrfToken) {\n      token\n      user {\n        ...UserDetailsFragment\n      }\n      errors {\n        ...AccountErrorFragment\n      }\n    }\n  }\n`;\n\nexport const VERIFY_TOKEN = gql`\n  ${accountErrorFragment}\n  ${userDetailsFragment}\n  mutation verifyToken($token: String!) {\n    tokenVerify(token: $token) {\n      isValid\n      payload\n      user {\n        ...UserDetailsFragment\n      }\n      errors {\n        ...AccountErrorFragment\n      }\n    }\n  }\n`;\n\nexport const EXTERNAL_AUTHENTICATION_URL = gql`\n  ${accountErrorFragment}\n  mutation externalAuthenticationUrl(\n    $pluginId: String = \"mirumee.authentication.openidconnect\"\n    $input: JSONString!\n  ) {\n    externalAuthenticationUrl(pluginId: $pluginId, input: $input) {\n      authenticationData\n      errors {\n        ...AccountErrorFragment\n      }\n    }\n  }\n`;\n\nexport const OBTAIN_EXTERNAL_ACCESS_TOKEN = gql`\n  ${accountErrorFragment}\n  ${userDetailsFragment}\n  mutation externalObtainAccessTokens(\n    $pluginId: String = \"mirumee.authentication.openidconnect\"\n    $input: JSONString!\n  ) {\n    externalObtainAccessTokens(pluginId: $pluginId, input: $input) {\n      token\n      csrfToken\n      user {\n        ...UserDetailsFragment\n      }\n      errors {\n        ...AccountErrorFragment\n      }\n    }\n  }\n`;\n\nexport const EXTERNAL_REFRESH = gql`\n  ${accountErrorFragment}\n  mutation externalRefresh(\n    $pluginId: String = \"mirumee.authentication.openidconnect\"\n    $input: JSONString!\n  ) {\n    externalRefresh(pluginId: $pluginId, input: $input) {\n      token\n      csrfToken\n      errors {\n        ...AccountErrorFragment\n      }\n    }\n  }\n`;\n\nexport const EXTERNAL_REFRESH_WITH_USER = gql`\n  ${accountErrorFragment}\n  ${userDetailsFragment}\n  mutation externalRefreshWithUser(\n    $pluginId: String = \"mirumee.authentication.openidconnect\"\n    $input: JSONString!\n  ) {\n    externalRefresh(pluginId: $pluginId, input: $input) {\n      token\n      csrfToken\n      user {\n        ...UserDetailsFragment\n      }\n      errors {\n        ...AccountErrorFragment\n      }\n    }\n  }\n`;\n\nexport const EXTERNAL_VERIFY_TOKEN = gql`\n  ${accountErrorFragment}\n  ${userDetailsFragment}\n  mutation externalVerify(\n    $pluginId: String = \"mirumee.authentication.openidconnect\"\n    $input: JSONString!\n  ) {\n    externalVerify(pluginId: $pluginId, input: $input) {\n      isValid\n      verifyData\n      user {\n        ...UserDetailsFragment\n        userPermissions {\n          code\n          name\n        }\n      }\n      errors {\n        ...AccountErrorFragment\n      }\n    }\n  }\n`;\n\nexport const EXTERNAL_LOGOUT = gql`\n  ${accountErrorFragment}\n  mutation externalLogout(\n    $pluginId: String = \"mirumee.authentication.openidconnect\"\n    $input: JSONString!\n  ) {\n    externalLogout(pluginId: $pluginId, input: $input) {\n      logoutData\n      errors {\n        ...AccountErrorFragment\n      }\n    }\n  }\n`;\n\nexport const CHANGE_USER_PASSWORD = gql`\n  ${accountErrorFragment}\n  mutation passwordChange($newPassword: String!, $oldPassword: String!) {\n    passwordChange(newPassword: $newPassword, oldPassword: $oldPassword) {\n      errors {\n        ...AccountErrorFragment\n      }\n    }\n  }\n`;\n\nexport const REQUEST_PASSWORD_RESET = gql`\n  ${accountErrorFragment}\n  mutation requestPasswordReset(\n    $email: String!\n    $redirectUrl: String!\n    $channel: String!\n  ) {\n    requestPasswordReset(\n      email: $email\n      redirectUrl: $redirectUrl\n      channel: $channel\n    ) {\n      errors {\n        ...AccountErrorFragment\n      }\n    }\n  }\n`;\n\nexport const SET_PASSWORD = gql`\n  ${userDetailsFragment}\n  ${accountErrorFragment}\n  mutation setPassword($token: String!, $email: String!, $password: String!) {\n    setPassword(token: $token, email: $email, password: $password) {\n      errors {\n        ...AccountErrorFragment\n      }\n      token\n      csrfToken\n      user {\n        ...UserDetailsFragment\n      }\n    }\n  }\n`;\n\nexport const REQUEST_EMAIL_CHANGE = gql`\n  ${userDetailsFragment}\n  ${accountErrorFragment}\n  mutation requestEmailChange(\n    $channel: String!\n    $newEmail: String!\n    $password: String!\n    $redirectUrl: String!\n  ) {\n    requestEmailChange(\n      channel: $channel\n      newEmail: $newEmail\n      password: $password\n      redirectUrl: $redirectUrl\n    ) {\n      errors {\n        ...AccountErrorFragment\n      }\n      user {\n        ...UserDetailsFragment\n      }\n    }\n  }\n`;\n\nexport const CONFIRM_EMAIL_CHANGE = gql`\n  ${userDetailsFragment}\n  ${accountErrorFragment}\n  mutation confirmEmailChange($channel: String!, $token: String!) {\n    confirmEmailChange(channel: $channel, token: $token) {\n      errors {\n        ...AccountErrorFragment\n      }\n      user {\n        ...UserDetailsFragment\n      }\n    }\n  }\n`;\n\nexport const REQUEST_DELETE_ACCOUNT = gql`\n  ${accountErrorFragment}\n  mutation accountRequestDeletion($channel: String!, $redirectUrl: String!) {\n    accountRequestDeletion(channel: $channel, redirectUrl: $redirectUrl) {\n      errors {\n        ...AccountErrorFragment\n      }\n    }\n  }\n`;\n\nexport const DELETE_ACCOUNT = gql`\n  ${userDetailsFragment}\n  ${accountErrorFragment}\n  mutation accountDelete($token: String!) {\n    accountDelete(token: $token) {\n      errors {\n        ...AccountErrorFragment\n      }\n      user {\n        ...UserDetailsFragment\n      }\n    }\n  }\n`;\n\nexport const UPDATE_ACCOUNT = gql`\n  ${userDetailsFragment}\n  ${accountErrorFragment}\n  mutation accountUpdate($input: AccountInput!) {\n    accountUpdate(input: $input) {\n      errors {\n        ...AccountErrorFragment\n      }\n      user {\n        ...UserDetailsFragment\n      }\n    }\n  }\n`;\n\nexport const SET_ACCOUNT_DEFAULT_ADDRESS = gql`\n  ${userDetailsFragment}\n  ${accountErrorFragment}\n  mutation setAccountDefaultAddress($id: ID!, $type: AddressTypeEnum!) {\n    accountSetDefaultAddress(id: $id, type: $type) {\n      errors {\n        ...AccountErrorFragment\n      }\n      user {\n        ...UserDetailsFragment\n      }\n    }\n  }\n`;\n\nexport const DELETE_ACCOUNT_ADDRESS = gql`\n  ${userDetailsFragment}\n  ${accountErrorFragment}\n  mutation deleteAccountAddress($addressId: ID!) {\n    accountAddressDelete(id: $addressId) {\n      errors {\n        ...AccountErrorFragment\n      }\n      user {\n        ...UserDetailsFragment\n      }\n    }\n  }\n`;\n\nexport const CREATE_ACCOUNT_ADDRESS = gql`\n  ${addressFragment}\n  ${userDetailsFragment}\n  ${accountErrorFragment}\n  mutation createAccountAddress($input: AddressInput!) {\n    accountAddressCreate(input: $input) {\n      address {\n        ...AddressFragment\n      }\n      errors {\n        ...AccountErrorFragment\n      }\n      user {\n        ...UserDetailsFragment\n      }\n    }\n  }\n`;\n\nexport const UPDATE_ACCOUNT_ADDRESS = gql`\n  ${addressFragment}\n  ${userDetailsFragment}\n  ${accountErrorFragment}\n  mutation updateAccountAddress($input: AddressInput!, $id: ID!) {\n    accountAddressUpdate(input: $input, id: $id) {\n      address {\n        ...AddressFragment\n      }\n      errors {\n        ...AccountErrorFragment\n      }\n      user {\n        ...UserDetailsFragment\n      }\n    }\n  }\n`;\n\nexport const CONFIRM_ACCOUNT = gql`\n  ${userDetailsFragment}\n  ${accountErrorFragment}\n  mutation accountConfirm($email: String!, $token: String!) {\n    confirmAccount(email: $email, token: $token) {\n      user {\n        ...UserDetailsFragment\n      }\n      errors {\n        ...AccountErrorFragment\n      }\n    }\n  }\n`;\n","export const WINDOW_EXISTS = typeof window !== \"undefined\";\nexport const LOCAL_STORAGE_EXISTS = WINDOW_EXISTS && !!window.localStorage;\nexport const DEVELOPMENT_MODE = process.env.NODE_ENV === \"development\";\n","import { gql } from \"@apollo/client\";\nimport { userBaseFragment, userDetailsFragment } from \"./fragments\";\n\nexport const USER_WITHOUT_DETAILS = gql`\n  ${userBaseFragment}\n  query UserWithoutDetails {\n    user: me {\n      ...UserBaseFragment\n    }\n    authenticated @client\n    authenticating @client\n  }\n`;\n\nexport const USER = gql`\n  ${userDetailsFragment}\n  query User {\n    user: me {\n      ...UserDetailsFragment\n    }\n    authenticated @client\n    authenticating @client\n  }\n`;\n","import {\n  CHANGE_USER_PASSWORD,\n  EXTERNAL_AUTHENTICATION_URL,\n  EXTERNAL_LOGOUT,\n  EXTERNAL_REFRESH,\n  EXTERNAL_VERIFY_TOKEN,\n  LOGIN,\n  OBTAIN_EXTERNAL_ACCESS_TOKEN,\n  REQUEST_PASSWORD_RESET,\n  REFRESH_TOKEN,\n  REGISTER,\n  SET_PASSWORD,\n  VERIFY_TOKEN,\n  REFRESH_TOKEN_WITH_USER,\n  EXTERNAL_REFRESH_WITH_USER,\n  LOGIN_WITHOUT_DETAILS,\n} from \"../apollo/mutations\";\nimport {\n  ExternalAuthenticationUrlMutation,\n  ExternalAuthenticationUrlMutationVariables,\n  ExternalLogoutMutation,\n  ExternalLogoutMutationVariables,\n  ExternalObtainAccessTokensMutation,\n  ExternalObtainAccessTokensMutationVariables,\n  ExternalRefreshMutation,\n  ExternalRefreshMutationVariables,\n  ExternalRefreshWithUserMutation,\n  ExternalRefreshWithUserMutationVariables,\n  ExternalVerifyMutation,\n  ExternalVerifyMutationVariables,\n  LoginMutation,\n  LoginMutationVariables,\n  PasswordChangeMutation,\n  PasswordChangeMutationVariables,\n  RefreshTokenMutation,\n  RefreshTokenMutationVariables,\n  RefreshTokenWithUserMutation,\n  RefreshTokenWithUserMutationVariables,\n  RegisterMutation,\n  RegisterMutationVariables,\n  RequestPasswordResetMutation,\n  RequestPasswordResetMutationVariables,\n  SetPasswordMutation,\n  SetPasswordMutationVariables,\n  VerifyTokenMutation,\n  VerifyTokenMutationVariables,\n} from \"../apollo/types\";\nimport {\n  ChangePasswordResult,\n  LogoutOpts,\n  GetExternalAccessTokenResult,\n  GetExternalAuthUrlResult,\n  LoginResult,\n  LogoutResult,\n  RefreshExternalTokenResult,\n  RefreshTokenResult,\n  RegisterResult,\n  RequestPasswordResetResult,\n  SaleorClientMethodsProps,\n  SetPasswordResult,\n  VerifyExternalTokenResult,\n  VerifyTokenResult,\n  GetExternalAuthUrlOpts,\n  GetExternalAccessTokenOpts,\n} from \"./types\";\nimport {\n  ChangePasswordOpts,\n  LoginOpts,\n  RegisterOpts,\n  RequestPasswordResetOpts,\n  SetPasswordOpts,\n} from \"./types\";\nimport { storage } from \"./storage\";\nimport { USER, USER_WITHOUT_DETAILS } from \"../apollo/queries\";\n\nexport interface AuthSDK {\n  /**\n   * Change the password of the logged in user.\n   *\n   * @param opts - Object with password and new password.\n   * @returns Errors if the passoword change has failed.\n   */\n  changePassword: (opts: ChangePasswordOpts) => Promise<ChangePasswordResult>;\n  /**\n   * Authenticates user with email and password.\n   *\n   * @param opts - Object with user's email, password and a boolean includeDetails - whether to fetch user details.\n   * Default for includeDetails is true.\n   * @returns Promise resolved with CreateToken type data.\n   */\n  login: (opts: LoginOpts) => Promise<LoginResult>;\n  /**\n   * Clears stored token and Apollo store. If external plugin was used to log in, the mutation will prepare\n   * the logout URL. All values passed in field input will be added as GET parameters to the logout request.\n   *\n   * @param opts - Object with input as JSON with returnTo - the URL where a user should be redirected\n   * when external plugin was used to log in\n   * @returns Logout data and errors if external plugin was used to log in. Otherwise null.\n   */\n  logout: (opts?: LogoutOpts) => Promise<LogoutResult>;\n  /**\n   * Refresh JWT token. Mutation will try to take refreshToken from the function's arguments.\n   * If it fails, it will try to use refreshToken from the http-only cookie called refreshToken.\n   *\n   * @param includeUser - Whether to fetch user. Default false.\n   * @returns Authorization token.\n   */\n  refreshToken: (includeUser?: boolean) => Promise<RefreshTokenResult>;\n  /**\n   * Registers user with email and password.\n   *\n   * @param opts - Object with user's data. Email and password are required fields.\n   * \"channel\" can be changed by using first \"setChannel\" method from api.\n   * @returns Promise resolved with AccountRegister type data.\n   */\n  register: (opts: RegisterOpts) => Promise<RegisterResult>;\n  /**\n   * Sends an email with the account password modification link.\n   *\n   * @param opts - Object with slug of a channel which will be used for notify user,\n   * email of the user that will be used for password recovery and URL of a view\n   * where users should be redirected to reset the password. URL in RFC 1808 format.\n   *\n   * @returns Errors if there were some.\n   */\n  requestPasswordReset: (\n    opts: RequestPasswordResetOpts\n  ) => Promise<RequestPasswordResetResult>;\n  /**\n   * Sets the user's password from the token sent by email.\n   *\n   * @param opts - Object with user's email, password and one-time token required to set the password.\n   * @returns User instance, JWT token, JWT refresh token and CSRF token.\n   */\n  setPassword: (opts: SetPasswordOpts) => Promise<SetPasswordResult>;\n  /**\n   * Verify JWT token.\n   *\n   * @param token - Token value.\n   * @returns User assigned to token and the information if the token is valid or not.\n   */\n  verifyToken: () => Promise<VerifyTokenResult>;\n  /**\n   * Executing externalAuthenticationUrl mutation will prepare special URL which will redirect user to requested\n   * page after successfull authentication. After redirection state and code fields will be added to the URL.\n   *\n   * @param opts - Object withpluginId default value set as \"mirumee.authentication.openidconnect\" and input as\n   * JSON with redirectUrl - the URL where the user should be redirected after successful authentication.\n   * @returns Authentication data and errors\n   */\n  getExternalAuthUrl: (\n    opts: GetExternalAuthUrlOpts\n  ) => Promise<GetExternalAuthUrlResult>;\n  /**\n   * The externalObtainAccessTokens mutation will generate requested access tokens.\n   *\n   * @param opts - Object withpluginId default value set as \"mirumee.authentication.openidconnect\" and input as\n   * JSON with code - the authorization code received from the OAuth provider and state - the state value received\n   * from the OAuth provider\n   * @returns Login authentication data and errors\n   */\n  getExternalAccessToken: (\n    opts: GetExternalAccessTokenOpts\n  ) => Promise<GetExternalAccessTokenResult>;\n  /**\n   * The externalRefresh mutation will generate new access tokens when provided with a valid refresh token.\n   *\n   * @param includeUser - Whether to fetch user. Default false.\n   * @returns Token refresh data and errors\n   */\n  refreshExternalToken: (\n    includeUser?: boolean\n  ) => Promise<RefreshExternalTokenResult>;\n  /**\n   * The mutation will verify the authentication token.\n   *\n   * @returns Token verification data and errors\n   */\n  verifyExternalToken: () => Promise<VerifyExternalTokenResult>;\n}\n\nexport const auth = ({\n  apolloClient: client,\n  channel,\n}: SaleorClientMethodsProps): AuthSDK => {\n  const login: AuthSDK[\"login\"] = ({ includeDetails = true, ...opts }) => {\n    const query = includeDetails ? USER : USER_WITHOUT_DETAILS;\n    const loginMutation = includeDetails ? LOGIN : LOGIN_WITHOUT_DETAILS;\n\n    client.writeQuery({\n      query,\n      data: {\n        authenticating: true,\n      },\n    });\n\n    return client.mutate<LoginMutation, LoginMutationVariables>({\n      mutation: loginMutation,\n      variables: {\n        ...opts,\n      },\n      update: (_, { data }) => {\n        if (data?.tokenCreate?.token) {\n          storage.setTokens({\n            accessToken: data.tokenCreate.token,\n            csrfToken: data.tokenCreate.csrfToken,\n          });\n        } else {\n          client.writeQuery({\n            query,\n            data: {\n              authenticating: false,\n            },\n          });\n        }\n      },\n    });\n  };\n\n  const logout: AuthSDK[\"logout\"] = async opts => {\n    const authPluginId = storage.getAuthPluginId();\n\n    storage.clear();\n\n    client.writeQuery({\n      query: USER,\n      data: {\n        authenticating: false,\n      },\n    });\n\n    client.resetStore();\n\n    if (authPluginId && opts?.input) {\n      const result = await client.mutate<\n        ExternalLogoutMutation,\n        ExternalLogoutMutationVariables\n      >({\n        mutation: EXTERNAL_LOGOUT,\n        variables: {\n          ...opts,\n          pluginId: authPluginId,\n        },\n      });\n      return result;\n    }\n    return null;\n  };\n\n  const register: AuthSDK[\"register\"] = async opts =>\n    await client.mutate<RegisterMutation, RegisterMutationVariables>({\n      mutation: REGISTER,\n      variables: {\n        input: {\n          ...opts,\n          channel,\n        },\n      },\n    });\n\n  const refreshToken: AuthSDK[\"refreshToken\"] = (includeUser = false) => {\n    const csrfToken = storage.getCSRFToken();\n\n    if (!csrfToken) {\n      throw Error(\"csrfToken not present\");\n    }\n\n    if (includeUser) {\n      return client.mutate<\n        RefreshTokenWithUserMutation,\n        RefreshTokenWithUserMutationVariables\n      >({\n        mutation: REFRESH_TOKEN_WITH_USER,\n        variables: {\n          csrfToken,\n        },\n        update: (_, { data }) => {\n          if (data?.tokenRefresh?.token) {\n            storage.setAccessToken(data.tokenRefresh.token);\n          } else {\n            logout();\n          }\n        },\n      });\n    }\n\n    return client.mutate<RefreshTokenMutation, RefreshTokenMutationVariables>({\n      mutation: REFRESH_TOKEN,\n      variables: {\n        csrfToken,\n      },\n      update: (_, { data }) => {\n        if (data?.tokenRefresh?.token) {\n          storage.setAccessToken(data.tokenRefresh.token);\n        } else {\n          logout();\n        }\n      },\n    });\n  };\n\n  const verifyToken: AuthSDK[\"verifyToken\"] = async () => {\n    const token = storage.getAccessToken();\n\n    if (!token) {\n      throw Error(\"Token not present\");\n    }\n\n    const result = await client.mutate<\n      VerifyTokenMutation,\n      VerifyTokenMutationVariables\n    >({\n      mutation: VERIFY_TOKEN,\n      variables: { token },\n    });\n\n    if (!result.data?.tokenVerify?.isValid) {\n      logout();\n    }\n\n    return result;\n  };\n\n  const changePassword: AuthSDK[\"changePassword\"] = async opts => {\n    const result = await client.mutate<\n      PasswordChangeMutation,\n      PasswordChangeMutationVariables\n    >({\n      mutation: CHANGE_USER_PASSWORD,\n      variables: { ...opts },\n    });\n\n    return result;\n  };\n\n  const requestPasswordReset: AuthSDK[\"requestPasswordReset\"] = async opts => {\n    const result = await client.mutate<\n      RequestPasswordResetMutation,\n      RequestPasswordResetMutationVariables\n    >({\n      mutation: REQUEST_PASSWORD_RESET,\n      variables: { ...opts, channel },\n    });\n\n    return result;\n  };\n\n  const setPassword: AuthSDK[\"setPassword\"] = opts => {\n    return client.mutate<SetPasswordMutation, SetPasswordMutationVariables>({\n      mutation: SET_PASSWORD,\n      variables: { ...opts },\n      update: (_, { data }) => {\n        if (data?.setPassword?.token) {\n          storage.setTokens({\n            accessToken: data.setPassword.token,\n            csrfToken: data.setPassword.csrfToken || null,\n          });\n        }\n      },\n    });\n  };\n\n  const getExternalAuthUrl: AuthSDK[\"getExternalAuthUrl\"] = async opts => {\n    const result = await client.mutate<\n      ExternalAuthenticationUrlMutation,\n      ExternalAuthenticationUrlMutationVariables\n    >({\n      mutation: EXTERNAL_AUTHENTICATION_URL,\n      variables: { ...opts },\n    });\n\n    return result;\n  };\n\n  const getExternalAccessToken: AuthSDK[\"getExternalAccessToken\"] = opts => {\n    client.writeQuery({\n      query: USER,\n      data: {\n        authenticating: true,\n      },\n    });\n\n    return client.mutate<\n      ExternalObtainAccessTokensMutation,\n      ExternalObtainAccessTokensMutationVariables\n    >({\n      mutation: OBTAIN_EXTERNAL_ACCESS_TOKEN,\n      variables: {\n        ...opts,\n      },\n      update: (_, { data }) => {\n        if (data?.externalObtainAccessTokens?.token) {\n          storage.setAuthPluginId(opts.pluginId);\n          storage.setTokens({\n            accessToken: data.externalObtainAccessTokens.token,\n            csrfToken: data.externalObtainAccessTokens.csrfToken || null,\n          });\n        } else {\n          client.writeQuery({\n            query: USER,\n            data: {\n              authenticating: false,\n            },\n          });\n        }\n      },\n    });\n  };\n\n  const refreshExternalToken: AuthSDK[\"refreshExternalToken\"] = (\n    includeUser = false\n  ) => {\n    const csrfToken = storage.getCSRFToken();\n    const authPluginId = storage.getAuthPluginId();\n\n    if (!csrfToken) {\n      throw Error(\"csrfToken not present\");\n    }\n\n    if (includeUser) {\n      return client.mutate<\n        ExternalRefreshWithUserMutation,\n        ExternalRefreshWithUserMutationVariables\n      >({\n        mutation: EXTERNAL_REFRESH_WITH_USER,\n        variables: {\n          pluginId: authPluginId,\n          input: JSON.stringify({\n            csrfToken,\n          }),\n        },\n        update: (_, { data }) => {\n          if (data?.externalRefresh?.token) {\n            storage.setTokens({\n              accessToken: data.externalRefresh.token,\n              csrfToken: data.externalRefresh.csrfToken || null,\n            });\n          } else {\n            logout();\n          }\n        },\n      });\n    }\n\n    return client.mutate<\n      ExternalRefreshMutation,\n      ExternalRefreshMutationVariables\n    >({\n      mutation: EXTERNAL_REFRESH,\n      variables: {\n        pluginId: authPluginId,\n        input: JSON.stringify({\n          csrfToken,\n        }),\n      },\n      update: (_, { data }) => {\n        if (data?.externalRefresh?.token) {\n          storage.setTokens({\n            accessToken: data.externalRefresh.token,\n            csrfToken: data.externalRefresh.csrfToken || null,\n          });\n        } else {\n          logout();\n        }\n      },\n    });\n  };\n\n  const verifyExternalToken: AuthSDK[\"verifyExternalToken\"] = async () => {\n    const csrfToken = storage.getCSRFToken();\n    const authPluginId = storage.getAuthPluginId();\n\n    if (!csrfToken) {\n      throw Error(\"csrfToken not present\");\n    }\n\n    const result = await client.mutate<\n      ExternalVerifyMutation,\n      ExternalVerifyMutationVariables\n    >({\n      mutation: EXTERNAL_VERIFY_TOKEN,\n      variables: {\n        pluginId: authPluginId,\n        input: JSON.stringify({\n          csrfToken,\n        }),\n      },\n    });\n\n    if (!result.data?.externalVerify?.isValid) {\n      storage.clear();\n    }\n\n    return result;\n  };\n\n  return {\n    changePassword,\n    getExternalAccessToken,\n    getExternalAuthUrl,\n    login,\n    logout,\n    refreshExternalToken,\n    refreshToken,\n    register,\n    requestPasswordReset,\n    setPassword,\n    verifyExternalToken,\n    verifyToken,\n  };\n};\n","import React from \"react\";\nimport { SaleorClient } from \"../../core\";\n\nexport type SaleorContextType = {\n  client: SaleorClient;\n};\n\nexport const SaleorContext = React.createContext<SaleorClient | null>(null);\n\nexport const SaleorProvider: React.FC<{ client: SaleorClient }> = ({\n  client,\n  children,\n}) => {\n  const [context, setContext] = React.useState<SaleorClient>(client);\n\n  React.useEffect(() => {\n    setContext(client);\n  }, [client]);\n\n  if (context) {\n    return (\n      <SaleorContext.Provider value={context}>\n        {children}\n      </SaleorContext.Provider>\n    );\n  }\n\n  return null;\n};\n","import { useContext } from \"react\";\nimport { SaleorClient } from \"../../core/types\";\nimport { SaleorContext } from \"../components/SaleorProvider\";\n\nconst CreateSaleorHook = <T extends keyof SaleorClient>(\n  key: T\n): SaleorClient[T] => {\n  const saleorClient = useContext(SaleorContext);\n\n  if (!saleorClient) {\n    throw new Error(\n      \"Could not find saleor's apollo client in the context. Did you forget to wrap the root component in a <SaleorProvider>?\"\n    );\n  }\n\n  const getHookData = (): SaleorClient[T] => {\n    return saleorClient[key];\n  };\n\n  return getHookData();\n};\n\nexport const hookFactory = <T extends keyof SaleorClient>(\n  query: T\n) => (): SaleorClient[T] => CreateSaleorHook(query);\n","import { USER } from \"../../apollo/queries\";\nimport { UserQuery, UserQueryVariables } from \"../../apollo/types\";\nimport { hookFactory } from \"../helpers/hookFactory\";\nimport { hookStateFactory } from \"../helpers/hookStateFactory\";\n\n/**\n * React hook to get authorization methods\n *\n * @returns Saleor's authorization methods\n */\nexport const useAuth = hookFactory(\"auth\");\n\n/**\n * React hook to get user's authentication data.\n *\n * @returns Object with user's data\n */\nexport const useAuthState = (): UserQuery => {\n  const { data } = hookStateFactory<UserQuery, UserQueryVariables>(USER);\n\n  if (!data) {\n    throw new Error(\n      \"Cache query result is undefined. Invalid cache configuration.\"\n    );\n  }\n\n  return data;\n};\n","import { hookFactory } from \"../helpers/hookFactory\";\n\n/**\n * React hook to get user's account methods\n *\n * @returns Saleor's user's account methods\n */\nexport const useUser = hookFactory(\"user\");\n","import { hookFactory } from \"../helpers/hookFactory\";\n\n/**\n * React hook to get client's config methods\n *\n * @returns Saleor's client's config methods\n */\nexport const useSaleorConfig = hookFactory(\"config\");\n","import { auth } from \"./auth\";\nimport { user } from \"./user\";\nimport { getState, State } from \"./state\";\nimport { createApolloClient } from \"../apollo\";\nimport { SaleorClient, SaleorClientOpts } from \"./types\";\n\nimport { createStorage, storage } from \"./storage\";\nimport { DEVELOPMENT_MODE, WINDOW_EXISTS } from \"../constants\";\n\nexport const createSaleorClient = ({\n  apiUrl,\n  channel,\n  opts = {},\n}: SaleorClientOpts): SaleorClient => {\n  let _channel = channel;\n  const { autologin = true, fetchOpts } = opts;\n\n  const setChannel = (channel: string): string => {\n    _channel = channel;\n    return _channel;\n  };\n\n  createStorage(autologin);\n  const apolloClient = createApolloClient(apiUrl, autologin, fetchOpts);\n  const coreInternals = { apolloClient, channel: _channel };\n  const authSDK = auth(coreInternals);\n  const userSDK = user(coreInternals);\n\n  if (autologin) {\n    const csrfToken = storage.getCSRFToken();\n    const authPluginId = storage.getAuthPluginId();\n\n    if (csrfToken && authPluginId) {\n      authSDK.refreshExternalToken(true);\n    } else if (csrfToken) {\n      authSDK.refreshToken(true);\n    }\n  }\n\n  const client = {\n    auth: authSDK,\n    user: userSDK,\n    config: { channel: _channel, setChannel, autologin },\n    _internal: { apolloClient },\n    getState: (): State => getState(apolloClient),\n  };\n\n  if (DEVELOPMENT_MODE && WINDOW_EXISTS) {\n    (window as any).__SALEOR_CLIENT__ = client;\n  }\n\n  return client;\n};\n","export const SALEOR_AUTH_PLUGIN_ID = \"_saleorAuthPluginId\";\nexport const SALEOR_CSRF_TOKEN = \"_saleorCSRFToken\";\n","import {\n  CONFIRM_ACCOUNT,\n  CONFIRM_EMAIL_CHANGE,\n  CREATE_ACCOUNT_ADDRESS,\n  DELETE_ACCOUNT,\n  DELETE_ACCOUNT_ADDRESS,\n  REQUEST_DELETE_ACCOUNT,\n  REQUEST_EMAIL_CHANGE,\n  SET_ACCOUNT_DEFAULT_ADDRESS,\n  UPDATE_ACCOUNT,\n  UPDATE_ACCOUNT_ADDRESS,\n} from \"../apollo/mutations\";\nimport {\n  AccountConfirmMutation,\n  AccountConfirmMutationVariables,\n  AccountDeleteMutation,\n  AccountDeleteMutationVariables,\n  AccountRequestDeletionMutation,\n  AccountRequestDeletionMutationVariables,\n  AccountUpdateMutation,\n  AccountUpdateMutationVariables,\n  ConfirmEmailChangeMutation,\n  ConfirmEmailChangeMutationVariables,\n  CreateAccountAddressMutation,\n  CreateAccountAddressMutationVariables,\n  DeleteAccountAddressMutation,\n  DeleteAccountAddressMutationVariables,\n  RequestEmailChangeMutation,\n  RequestEmailChangeMutationVariables,\n  SetAccountDefaultAddressMutation,\n  SetAccountDefaultAddressMutationVariables,\n  UpdateAccountAddressMutation,\n  UpdateAccountAddressMutationVariables,\n} from \"../apollo/types\";\nimport { auth } from \"./auth\";\nimport {\n  AccountDeleteResult,\n  AccountRequestDeletionResult,\n  ConfirmAccountOpts,\n  ConfirmAccountResult,\n  ConfirmEmailChangeResult,\n  CreateAccountAddressResult,\n  DeleteAccountAddressResult,\n  RequestEmailChangeResult,\n  SaleorClientMethodsProps,\n  SetAccountDefaultAddressResult,\n  UpdateAccountAddressResult,\n  UpdateAccountResult,\n} from \"./types\";\nimport {\n  CreateAccountAddressOpts,\n  RequestEmailChangeOpts,\n  SetAccountDefaultAddressOpts,\n  UpdateAccountOpts,\n  UpdateAccountAddressOpts,\n} from \"./types\";\n\nexport interface UserSDK {\n  /**\n   * Remove user account.\n   *\n   * @param token - A one-time token required to remove account. Sent by email using AccountRequestDeletion mutation.\n   * @returns Deleted user's account data and errors.\n   */\n  accountDelete: (token: string) => Promise<AccountDeleteResult>;\n  /**\n   * Sends an email with the account removal link for the logged-in user.\n   *\n   * @param redirectUrl - URL of a view where users should be redirected to delete their account. URL in RFC 1808 format.\n   * @returns Errors if there are some.\n   */\n  accountRequestDeletion: (\n    redirectUrl: string\n  ) => Promise<AccountRequestDeletionResult>;\n  /**\n   * Confirm the email change of the logged-in user.\n   *\n   * @param token - A one-time token required to change the email.\n   * @returns A user instance with a new email and errors.\n   */\n  confirmEmailChange: (token: string) => Promise<ConfirmEmailChangeResult>;\n  /**\n   * Create a new address for the account.\n   *\n   * @param opts - Object with fields required to create address and a type of address.\n   * If provided, the new address will be automatically assigned as the customer's default address of that type.\n   * @returns Updated user account.\n   */\n  createAccountAddress: (\n    opts: CreateAccountAddressOpts\n  ) => Promise<CreateAccountAddressResult>;\n  /**\n   * Delete an address of the logged-in account.\n   *\n   * @param addressId - ID of the address to delete.\n   * @returns Updated user account.\n   */\n  deleteAccountAddress: (\n    addressId: string\n  ) => Promise<DeleteAccountAddressResult>;\n  /**\n   * Request email change of the logged in user.\n   *\n   * @param opts - Object with new user email, user's password and URL of a view where users should be redirected to update the email address.\n   * @returns A user instance and errors.\n   */\n  requestEmailChange: (\n    opts: RequestEmailChangeOpts\n  ) => Promise<RequestEmailChangeResult>;\n  /**\n   * Sets a default address for the authenticated account.\n   *\n   * @param opts - Object with ID of the address to set as default and the type of address.\n   * @returns Updated user account.\n   */\n  setAccountDefaultAddress: (\n    opts: SetAccountDefaultAddressOpts\n  ) => Promise<SetAccountDefaultAddressResult>;\n  /**\n   * Updates the account of the logged-in account.\n   *\n   * @param opts - Fields required to update the account of the logged-in account.\n   * @returns Updated user account.\n   */\n  updateAccount: (opts: UpdateAccountOpts) => Promise<UpdateAccountResult>;\n  /**\n   * Updates an address of the logged-in account.\n   *\n   * @param opts - Object with ID of the address to update and fields required to update the address.\n   * @returns Updated user account.\n   */\n  updateAccountAddress: (\n    opts: UpdateAccountAddressOpts\n  ) => Promise<UpdateAccountAddressResult>;\n  /**\n   * Confirms user account with token sent by email during registration.\n   *\n   * @param opts - Object with email of the user and one-time token required to confirm the account.\n   * @returns Confirmed user account.\n   */\n  confirmAccount: (opts: ConfirmAccountOpts) => Promise<ConfirmAccountResult>;\n}\n\nexport const user = ({\n  apolloClient: client,\n  channel,\n}: SaleorClientMethodsProps): UserSDK => {\n  const _auth = auth({ apolloClient: client, channel });\n\n  const accountDelete: UserSDK[\"accountDelete\"] = async token => {\n    const result = await client.mutate<\n      AccountDeleteMutation,\n      AccountDeleteMutationVariables\n    >({\n      mutation: DELETE_ACCOUNT,\n      variables: { token },\n    });\n\n    _auth.logout();\n\n    return result;\n  };\n\n  const accountRequestDeletion: UserSDK[\"accountRequestDeletion\"] = async redirectUrl => {\n    const result = await client.mutate<\n      AccountRequestDeletionMutation,\n      AccountRequestDeletionMutationVariables\n    >({\n      mutation: REQUEST_DELETE_ACCOUNT,\n      variables: { channel, redirectUrl },\n    });\n\n    return result;\n  };\n\n  const confirmEmailChange: UserSDK[\"confirmEmailChange\"] = async token => {\n    const result = await client.mutate<\n      ConfirmEmailChangeMutation,\n      ConfirmEmailChangeMutationVariables\n    >({\n      mutation: CONFIRM_EMAIL_CHANGE,\n      variables: { channel, token },\n    });\n\n    return result;\n  };\n\n  const requestEmailChange: UserSDK[\"requestEmailChange\"] = async opts => {\n    const result = await client.mutate<\n      RequestEmailChangeMutation,\n      RequestEmailChangeMutationVariables\n    >({\n      mutation: REQUEST_EMAIL_CHANGE,\n      variables: { ...opts, channel: opts.channel || channel },\n    });\n\n    return result;\n  };\n\n  const updateAccount: UserSDK[\"updateAccount\"] = async opts => {\n    const result = await client.mutate<\n      AccountUpdateMutation,\n      AccountUpdateMutationVariables\n    >({\n      mutation: UPDATE_ACCOUNT,\n      variables: { ...opts },\n    });\n\n    return result;\n  };\n\n  const setAccountDefaultAddress: UserSDK[\"setAccountDefaultAddress\"] = async opts => {\n    const result = await client.mutate<\n      SetAccountDefaultAddressMutation,\n      SetAccountDefaultAddressMutationVariables\n    >({\n      mutation: SET_ACCOUNT_DEFAULT_ADDRESS,\n      variables: { ...opts },\n    });\n\n    return result;\n  };\n\n  const createAccountAddress: UserSDK[\"createAccountAddress\"] = async opts => {\n    const result = await client.mutate<\n      CreateAccountAddressMutation,\n      CreateAccountAddressMutationVariables\n    >({\n      mutation: CREATE_ACCOUNT_ADDRESS,\n      variables: { ...opts },\n    });\n\n    return result;\n  };\n\n  const deleteAccountAddress: UserSDK[\"deleteAccountAddress\"] = async addressId => {\n    const result = await client.mutate<\n      DeleteAccountAddressMutation,\n      DeleteAccountAddressMutationVariables\n    >({\n      mutation: DELETE_ACCOUNT_ADDRESS,\n      variables: { addressId },\n    });\n\n    return result;\n  };\n\n  const updateAccountAddress: UserSDK[\"updateAccountAddress\"] = async opts => {\n    const result = await client.mutate<\n      UpdateAccountAddressMutation,\n      UpdateAccountAddressMutationVariables\n    >({\n      mutation: UPDATE_ACCOUNT_ADDRESS,\n      variables: { ...opts },\n    });\n\n    return result;\n  };\n\n  const confirmAccount: UserSDK[\"confirmAccount\"] = async opts => {\n    const result = await client.mutate<\n      AccountConfirmMutation,\n      AccountConfirmMutationVariables\n    >({\n      mutation: CONFIRM_ACCOUNT,\n      variables: { ...opts },\n    });\n\n    return result;\n  };\n\n  return {\n    accountDelete,\n    accountRequestDeletion,\n    confirmEmailChange,\n    createAccountAddress,\n    deleteAccountAddress,\n    requestEmailChange,\n    updateAccount,\n    updateAccountAddress,\n    setAccountDefaultAddress,\n    confirmAccount,\n  };\n};\n","import { USER } from \"../apollo/queries\";\nimport { UserQuery } from \"../apollo/types\";\nimport { SaleorClientInternals } from \"./types\";\n\nexport type State = UserQuery | null;\n\nexport const getState = (\n  client: SaleorClientInternals[\"apolloClient\"]\n): State =>\n  client.readQuery<UserQuery>({\n    query: USER,\n  });\n","import { useContext } from \"react\";\nimport { DocumentNode, QueryResult, useQuery } from \"@apollo/client\";\nimport { SaleorContext } from \"../components/SaleorProvider\";\n\nconst CreateSaleorStateHook = <TData, TVariables>(\n  query: DocumentNode\n): QueryResult<TData, TVariables> => {\n  const saleorClient = useContext(SaleorContext);\n\n  if (!saleorClient) {\n    throw new Error(\n      \"Could not find saleor's apollo client in the context. Did you forget to wrap the root component in a <SaleorProvider>?\"\n    );\n  }\n\n  return useQuery<TData, TVariables>(query, {\n    client: saleorClient._internal.apolloClient,\n    fetchPolicy: \"cache-only\",\n  });\n};\n\nexport const hookStateFactory = <TData, TVariables>(\n  query: DocumentNode\n): QueryResult<TData, TVariables> =>\n  CreateSaleorStateHook<TData, TVariables>(query);\n"],"names":["storage","client","authClient","runtime","exports","Op","Object","prototype","hasOwn","hasOwnProperty","$Symbol","Symbol","iteratorSymbol","iterator","asyncIteratorSymbol","asyncIterator","toStringTagSymbol","toStringTag","define","obj","key","value","defineProperty","enumerable","configurable","writable","err","wrap","innerFn","outerFn","self","tryLocsList","generator","create","Generator","context","Context","_invoke","state","method","arg","Error","undefined","done","delegate","delegateResult","maybeInvokeDelegate","ContinueSentinel","sent","_sent","dispatchException","abrupt","record","tryCatch","type","makeInvokeMethod","fn","call","GeneratorFunction","GeneratorFunctionPrototype","IteratorPrototype","this","getProto","getPrototypeOf","NativeIteratorPrototype","values","Gp","defineIteratorMethods","forEach","AsyncIterator","PromiseImpl","previousPromise","callInvokeWithMethodAndArg","resolve","reject","invoke","result","__await","then","unwrapped","error","TypeError","info","resultName","next","nextLoc","pushTryEntry","locs","entry","tryLoc","catchLoc","finallyLoc","afterLoc","tryEntries","push","resetTryEntry","completion","reset","iterable","iteratorMethod","isNaN","length","i","doneResult","constructor","displayName","isGeneratorFunction","genFun","ctor","name","mark","setPrototypeOf","__proto__","awrap","async","Promise","iter","toString","keys","object","reverse","pop","skipTempReset","prev","charAt","slice","stop","rootRecord","rval","exception","handle","loc","caught","hasCatch","hasFinally","finallyEntry","complete","finish","catch","thrown","delegateYield","module","regeneratorRuntime","accidentalStrictMode","Function","accountErrorFragment","gql","addressFragment","userBaseFragment","userDetailsFragment","LOGIN_WITHOUT_DETAILS","LOGIN","REGISTER","REFRESH_TOKEN","REFRESH_TOKEN_WITH_USER","VERIFY_TOKEN","EXTERNAL_AUTHENTICATION_URL","OBTAIN_EXTERNAL_ACCESS_TOKEN","EXTERNAL_REFRESH","EXTERNAL_REFRESH_WITH_USER","EXTERNAL_VERIFY_TOKEN","EXTERNAL_LOGOUT","CHANGE_USER_PASSWORD","REQUEST_PASSWORD_RESET","SET_PASSWORD","REQUEST_EMAIL_CHANGE","CONFIRM_EMAIL_CHANGE","REQUEST_DELETE_ACCOUNT","DELETE_ACCOUNT","UPDATE_ACCOUNT","SET_ACCOUNT_DEFAULT_ADDRESS","DELETE_ACCOUNT_ADDRESS","CREATE_ACCOUNT_ADDRESS","UPDATE_ACCOUNT_ADDRESS","CONFIRM_ACCOUNT","LOCAL_STORAGE_EXISTS","window","localStorage","USER_WITHOUT_DETAILS","USER","auth","apolloClient","channel","logout","opts","authPluginId","getAuthPluginId","clear","writeQuery","query","data","authenticating","resetStore","input","mutate","mutation","variables","pluginId","register","verifyToken","token","getAccessToken","_result$data","tokenVerify","_result$data$tokenVer","isValid","changePassword","requestPasswordReset","getExternalAccessToken","update","_","externalObtainAccessTokens","_data$externalObtainA","setAuthPluginId","setTokens","accessToken","csrfToken","getExternalAuthUrl","login","includeDetails","loginMutation","tokenCreate","_data$tokenCreate","refreshExternalToken","includeUser","getCSRFToken","JSON","stringify","externalRefresh","_data$externalRefresh","_data$externalRefresh2","refreshToken","tokenRefresh","_data$tokenRefresh","setAccessToken","_data$tokenRefresh2","setPassword","_data$setPassword","verifyExternalToken","_result$data2","externalVerify","_result$data2$externa","refreshPromise","createFetch","autoTokenRefresh","tokenRefreshTimeSkew","refreshOnUnauthorized","init","includes","parse","body","operationName","fetch","expirationTime","jwtDecode","exp","Date","now","headers","response","clone","json","isUnauthenticated","errors","_data$errors","some","extensions","code","refreshTokenResponse","_refreshTokenResponse","_refreshTokenResponse2","_refreshTokenResponse3","getTypePolicies","autologin","Query","fields","authenticated","read","readField","toReference","__typename","me","canRead","ref","User","keyFields","addresses","merge","createApolloClient","apiUrl","fetchOptions","httpLink","createHttpLink","uri","credentials","cache","InMemoryCache","typePolicies","ApolloClient","link","SaleorContext","React","createContext","hookFactory","saleorClient","useContext","CreateSaleorHook","useAuth","useUser","useSaleorConfig","children","useState","setContext","useEffect","Provider","_channel","fetchOpts","autologinEnabled","getItem","setItem","removeItem","setCSRFToken","createStorage","coreInternals","authSDK","userSDK","_auth","accountDelete","accountRequestDeletion","redirectUrl","confirmEmailChange","requestEmailChange","updateAccount","setAccountDefaultAddress","createAccountAddress","deleteAccountAddress","addressId","updateAccountAddress","confirmAccount","user","config","setChannel","_internal","getState","readQuery","useQuery","fetchPolicy","CreateSaleorStateHook"],"mappings":"u3BAGWA,MCcPC,EACAC,mBCXJ,IAAIC,EAAW,SAAUC,GAGvB,IAAIC,EAAKC,OAAOC,UACZC,EAASH,EAAGI,eAEZC,EAA4B,mBAAXC,OAAwBA,OAAS,GAClDC,EAAiBF,EAAQG,UAAY,aACrCC,EAAsBJ,EAAQK,eAAiB,kBAC/CC,EAAoBN,EAAQO,aAAe,gBAE/C,SAASC,EAAOC,EAAKC,EAAKC,GAOxB,OANAf,OAAOgB,eAAeH,EAAKC,EAAK,CAC9BC,MAAOA,EACPE,YAAY,EACZC,cAAc,EACdC,UAAU,IAELN,EAAIC,GAEb,IAEEF,EAAO,GAAI,IACX,MAAOQ,GACPR,EAAS,SAASC,EAAKC,EAAKC,GAC1B,OAAOF,EAAIC,GAAOC,GAItB,SAASM,EAAKC,EAASC,EAASC,EAAMC,GAEpC,IACIC,EAAY1B,OAAO2B,QADFJ,GAAWA,EAAQtB,qBAAqB2B,EAAYL,EAAUK,GACtC3B,WACzC4B,EAAU,IAAIC,EAAQL,GAAe,IAMzC,OAFAC,EAAUK,QAsMZ,SAA0BT,EAASE,EAAMK,GACvC,IAAIG,EA/KuB,iBAiL3B,OAAO,SAAgBC,EAAQC,GAC7B,GAhLoB,cAgLhBF,EACF,MAAM,IAAIG,MAAM,gCAGlB,GAnLoB,cAmLhBH,EAA6B,CAC/B,GAAe,UAAXC,EACF,MAAMC,EAKR,MAoQG,CAAEnB,WAzfPqB,EAyfyBC,MAAM,GA9P/B,IAHAR,EAAQI,OAASA,EACjBJ,EAAQK,IAAMA,IAED,CACX,IAAII,EAAWT,EAAQS,SACvB,GAAIA,EAAU,CACZ,IAAIC,EAAiBC,EAAoBF,EAAUT,GACnD,GAAIU,EAAgB,CAClB,GAAIA,IAAmBE,EAAkB,SACzC,OAAOF,GAIX,GAAuB,SAAnBV,EAAQI,OAGVJ,EAAQa,KAAOb,EAAQc,MAAQd,EAAQK,SAElC,GAAuB,UAAnBL,EAAQI,OAAoB,CACrC,GAnNqB,mBAmNjBD,EAEF,MADAA,EAjNc,YAkNRH,EAAQK,IAGhBL,EAAQe,kBAAkBf,EAAQK,SAEN,WAAnBL,EAAQI,QACjBJ,EAAQgB,OAAO,SAAUhB,EAAQK,KAGnCF,EA5NkB,YA8NlB,IAAIc,EAASC,EAASzB,EAASE,EAAMK,GACrC,GAAoB,WAAhBiB,EAAOE,KAAmB,CAO5B,GAJAhB,EAAQH,EAAQQ,KAjOA,YAFK,iBAuOjBS,EAAOZ,MAAQO,EACjB,SAGF,MAAO,CACL1B,MAAO+B,EAAOZ,IACdG,KAAMR,EAAQQ,MAGS,UAAhBS,EAAOE,OAChBhB,EA/OgB,YAkPhBH,EAAQI,OAAS,QACjBJ,EAAQK,IAAMY,EAAOZ,OA9QPe,CAAiB3B,EAASE,EAAMK,GAE7CH,EAcT,SAASqB,EAASG,EAAIrC,EAAKqB,GACzB,IACE,MAAO,CAAEc,KAAM,SAAUd,IAAKgB,EAAGC,KAAKtC,EAAKqB,IAC3C,MAAOd,GACP,MAAO,CAAE4B,KAAM,QAASd,IAAKd,IAhBjCtB,EAAQuB,KAAOA,EAoBf,IAOIoB,EAAmB,GAMvB,SAASb,KACT,SAASwB,KACT,SAASC,KAIT,IAAIC,EAAoB,GACxBA,EAAkBhD,GAAkB,WAClC,OAAOiD,MAGT,IAAIC,EAAWxD,OAAOyD,eAClBC,EAA0BF,GAAYA,EAASA,EAASG,EAAO,MAC/DD,GACAA,IAA4B3D,GAC5BG,EAAOiD,KAAKO,EAAyBpD,KAGvCgD,EAAoBI,GAGtB,IAAIE,EAAKP,EAA2BpD,UAClC2B,EAAU3B,UAAYD,OAAO2B,OAAO2B,GAWtC,SAASO,EAAsB5D,GAC7B,CAAC,OAAQ,QAAS,UAAU6D,SAAQ,SAAS7B,GAC3CrB,EAAOX,EAAWgC,GAAQ,SAASC,GACjC,OAAOqB,KAAKxB,QAAQE,EAAQC,SAkClC,SAAS6B,EAAcrC,EAAWsC,GAgChC,IAAIC,EAgCJV,KAAKxB,QA9BL,SAAiBE,EAAQC,GACvB,SAASgC,IACP,OAAO,IAAIF,GAAY,SAASG,EAASC,IAnC7C,SAASC,EAAOpC,EAAQC,EAAKiC,EAASC,GACpC,IAAItB,EAASC,EAASrB,EAAUO,GAASP,EAAWQ,GACpD,GAAoB,UAAhBY,EAAOE,KAEJ,CACL,IAAIsB,EAASxB,EAAOZ,IAChBnB,EAAQuD,EAAOvD,MACnB,OAAIA,GACiB,iBAAVA,GACPb,EAAOiD,KAAKpC,EAAO,WACdiD,EAAYG,QAAQpD,EAAMwD,SAASC,MAAK,SAASzD,GACtDsD,EAAO,OAAQtD,EAAOoD,EAASC,MAC9B,SAAShD,GACViD,EAAO,QAASjD,EAAK+C,EAASC,MAI3BJ,EAAYG,QAAQpD,GAAOyD,MAAK,SAASC,GAI9CH,EAAOvD,MAAQ0D,EACfN,EAAQG,MACP,SAASI,GAGV,OAAOL,EAAO,QAASK,EAAOP,EAASC,MAvBzCA,EAAOtB,EAAOZ,KAiCZmC,CAAOpC,EAAQC,EAAKiC,EAASC,MAIjC,OAAOH,EAaLA,EAAkBA,EAAgBO,KAChCN,EAGAA,GACEA,KAkHV,SAAS1B,EAAoBF,EAAUT,GACrC,IAAII,EAASK,EAAS/B,SAASsB,EAAQI,QACvC,QA1TEG,IA0TEH,EAAsB,CAKxB,GAFAJ,EAAQS,SAAW,KAEI,UAAnBT,EAAQI,OAAoB,CAE9B,GAAIK,EAAS/B,SAAiB,SAG5BsB,EAAQI,OAAS,SACjBJ,EAAQK,SArUZE,EAsUII,EAAoBF,EAAUT,GAEP,UAAnBA,EAAQI,QAGV,OAAOQ,EAIXZ,EAAQI,OAAS,QACjBJ,EAAQK,IAAM,IAAIyC,UAChB,kDAGJ,OAAOlC,EAGT,IAAIK,EAASC,EAASd,EAAQK,EAAS/B,SAAUsB,EAAQK,KAEzD,GAAoB,UAAhBY,EAAOE,KAIT,OAHAnB,EAAQI,OAAS,QACjBJ,EAAQK,IAAMY,EAAOZ,IACrBL,EAAQS,SAAW,KACZG,EAGT,IAAImC,EAAO9B,EAAOZ,IAElB,OAAM0C,EAOFA,EAAKvC,MAGPR,EAAQS,EAASuC,YAAcD,EAAK7D,MAGpCc,EAAQiD,KAAOxC,EAASyC,QAQD,WAAnBlD,EAAQI,SACVJ,EAAQI,OAAS,OACjBJ,EAAQK,SAzXVE,GAmYFP,EAAQS,SAAW,KACZG,GANEmC,GA3BP/C,EAAQI,OAAS,QACjBJ,EAAQK,IAAM,IAAIyC,UAAU,oCAC5B9C,EAAQS,SAAW,KACZG,GAoDX,SAASuC,EAAaC,GACpB,IAAIC,EAAQ,CAAEC,OAAQF,EAAK,IAEvB,KAAKA,IACPC,EAAME,SAAWH,EAAK,IAGpB,KAAKA,IACPC,EAAMG,WAAaJ,EAAK,GACxBC,EAAMI,SAAWL,EAAK,IAGxB1B,KAAKgC,WAAWC,KAAKN,GAGvB,SAASO,EAAcP,GACrB,IAAIpC,EAASoC,EAAMQ,YAAc,GACjC5C,EAAOE,KAAO,gBACPF,EAAOZ,IACdgD,EAAMQ,WAAa5C,EAGrB,SAAShB,EAAQL,GAIf8B,KAAKgC,WAAa,CAAC,CAAEJ,OAAQ,SAC7B1D,EAAYqC,QAAQkB,EAAczB,MAClCA,KAAKoC,OAAM,GA8Bb,SAAShC,EAAOiC,GACd,GAAIA,EAAU,CACZ,IAAIC,EAAiBD,EAAStF,GAC9B,GAAIuF,EACF,OAAOA,EAAe1C,KAAKyC,GAG7B,GAA6B,mBAAlBA,EAASd,KAClB,OAAOc,EAGT,IAAKE,MAAMF,EAASG,QAAS,CAC3B,IAAIC,GAAK,EAAGlB,EAAO,SAASA,IAC1B,OAASkB,EAAIJ,EAASG,QACpB,GAAI7F,EAAOiD,KAAKyC,EAAUI,GAGxB,OAFAlB,EAAK/D,MAAQ6E,EAASI,GACtBlB,EAAKzC,MAAO,EACLyC,EAOX,OAHAA,EAAK/D,WAzeTqB,EA0eI0C,EAAKzC,MAAO,EAELyC,GAGT,OAAOA,EAAKA,KAAOA,GAKvB,MAAO,CAAEA,KAAMmB,GAIjB,SAASA,IACP,MAAO,CAAElF,WAzfPqB,EAyfyBC,MAAM,GA+MnC,OA5mBAe,EAAkBnD,UAAY2D,EAAGsC,YAAc7C,EAC/CA,EAA2B6C,YAAc9C,EACzCA,EAAkB+C,YAAcvF,EAC9ByC,EACA3C,EACA,qBAaFZ,EAAQsG,oBAAsB,SAASC,GACrC,IAAIC,EAAyB,mBAAXD,GAAyBA,EAAOH,YAClD,QAAOI,IACHA,IAASlD,GAG2B,uBAAnCkD,EAAKH,aAAeG,EAAKC,QAIhCzG,EAAQ0G,KAAO,SAASH,GAQtB,OAPIrG,OAAOyG,eACTzG,OAAOyG,eAAeJ,EAAQhD,IAE9BgD,EAAOK,UAAYrD,EACnBzC,EAAOyF,EAAQ3F,EAAmB,sBAEpC2F,EAAOpG,UAAYD,OAAO2B,OAAOiC,GAC1ByC,GAOTvG,EAAQ6G,MAAQ,SAASzE,GACvB,MAAO,CAAEqC,QAASrC,IAsEpB2B,EAAsBE,EAAc9D,WACpC8D,EAAc9D,UAAUO,GAAuB,WAC7C,OAAO+C,MAETzD,EAAQiE,cAAgBA,EAKxBjE,EAAQ8G,MAAQ,SAAStF,EAASC,EAASC,EAAMC,EAAauC,QACxC,IAAhBA,IAAwBA,EAAc6C,SAE1C,IAAIC,EAAO,IAAI/C,EACb1C,EAAKC,EAASC,EAASC,EAAMC,GAC7BuC,GAGF,OAAOlE,EAAQsG,oBAAoB7E,GAC/BuF,EACAA,EAAKhC,OAAON,MAAK,SAASF,GACxB,OAAOA,EAAOjC,KAAOiC,EAAOvD,MAAQ+F,EAAKhC,WAuKjDjB,EAAsBD,GAEtBhD,EAAOgD,EAAIlD,EAAmB,aAO9BkD,EAAGtD,GAAkB,WACnB,OAAOiD,MAGTK,EAAGmD,SAAW,WACZ,MAAO,sBAkCTjH,EAAQkH,KAAO,SAASC,GACtB,IAAID,EAAO,GACX,IAAK,IAAIlG,KAAOmG,EACdD,EAAKxB,KAAK1E,GAMZ,OAJAkG,EAAKE,UAIE,SAASpC,IACd,KAAOkC,EAAKjB,QAAQ,CAClB,IAAIjF,EAAMkG,EAAKG,MACf,GAAIrG,KAAOmG,EAGT,OAFAnC,EAAK/D,MAAQD,EACbgE,EAAKzC,MAAO,EACLyC,EAQX,OADAA,EAAKzC,MAAO,EACLyC,IAsCXhF,EAAQ6D,OAASA,EAMjB7B,EAAQ7B,UAAY,CAClBiG,YAAapE,EAEb6D,MAAO,SAASyB,GAcd,GAbA7D,KAAK8D,KAAO,EACZ9D,KAAKuB,KAAO,EAGZvB,KAAKb,KAAOa,KAAKZ,WApgBjBP,EAqgBAmB,KAAKlB,MAAO,EACZkB,KAAKjB,SAAW,KAEhBiB,KAAKtB,OAAS,OACdsB,KAAKrB,SAzgBLE,EA2gBAmB,KAAKgC,WAAWzB,QAAQ2B,IAEnB2B,EACH,IAAK,IAAIb,KAAQhD,KAEQ,MAAnBgD,EAAKe,OAAO,IACZpH,EAAOiD,KAAKI,KAAMgD,KACjBT,OAAOS,EAAKgB,MAAM,MACrBhE,KAAKgD,QAnhBXnE,IAyhBFoF,KAAM,WACJjE,KAAKlB,MAAO,EAEZ,IACIoF,EADYlE,KAAKgC,WAAW,GACLG,WAC3B,GAAwB,UAApB+B,EAAWzE,KACb,MAAMyE,EAAWvF,IAGnB,OAAOqB,KAAKmE,MAGd9E,kBAAmB,SAAS+E,GAC1B,GAAIpE,KAAKlB,KACP,MAAMsF,EAGR,IAAI9F,EAAU0B,KACd,SAASqE,EAAOC,EAAKC,GAYnB,OAXAhF,EAAOE,KAAO,QACdF,EAAOZ,IAAMyF,EACb9F,EAAQiD,KAAO+C,EAEXC,IAGFjG,EAAQI,OAAS,OACjBJ,EAAQK,SApjBZE,KAujBY0F,EAGZ,IAAK,IAAI9B,EAAIzC,KAAKgC,WAAWQ,OAAS,EAAGC,GAAK,IAAKA,EAAG,CACpD,IAAId,EAAQ3B,KAAKgC,WAAWS,GACxBlD,EAASoC,EAAMQ,WAEnB,GAAqB,SAAjBR,EAAMC,OAIR,OAAOyC,EAAO,OAGhB,GAAI1C,EAAMC,QAAU5B,KAAK8D,KAAM,CAC7B,IAAIU,EAAW7H,EAAOiD,KAAK+B,EAAO,YAC9B8C,EAAa9H,EAAOiD,KAAK+B,EAAO,cAEpC,GAAI6C,GAAYC,EAAY,CAC1B,GAAIzE,KAAK8D,KAAOnC,EAAME,SACpB,OAAOwC,EAAO1C,EAAME,UAAU,GACzB,GAAI7B,KAAK8D,KAAOnC,EAAMG,WAC3B,OAAOuC,EAAO1C,EAAMG,iBAGjB,GAAI0C,GACT,GAAIxE,KAAK8D,KAAOnC,EAAME,SACpB,OAAOwC,EAAO1C,EAAME,UAAU,OAG3B,CAAA,IAAI4C,EAMT,MAAM,IAAI7F,MAAM,0CALhB,GAAIoB,KAAK8D,KAAOnC,EAAMG,WACpB,OAAOuC,EAAO1C,EAAMG,gBAU9BxC,OAAQ,SAASG,EAAMd,GACrB,IAAK,IAAI8D,EAAIzC,KAAKgC,WAAWQ,OAAS,EAAGC,GAAK,IAAKA,EAAG,CACpD,IAAId,EAAQ3B,KAAKgC,WAAWS,GAC5B,GAAId,EAAMC,QAAU5B,KAAK8D,MACrBnH,EAAOiD,KAAK+B,EAAO,eACnB3B,KAAK8D,KAAOnC,EAAMG,WAAY,CAChC,IAAI4C,EAAe/C,EACnB,OAIA+C,IACU,UAATjF,GACS,aAATA,IACDiF,EAAa9C,QAAUjD,GACvBA,GAAO+F,EAAa5C,aAGtB4C,EAAe,MAGjB,IAAInF,EAASmF,EAAeA,EAAavC,WAAa,GAItD,OAHA5C,EAAOE,KAAOA,EACdF,EAAOZ,IAAMA,EAET+F,GACF1E,KAAKtB,OAAS,OACdsB,KAAKuB,KAAOmD,EAAa5C,WAClB5C,GAGFc,KAAK2E,SAASpF,IAGvBoF,SAAU,SAASpF,EAAQwC,GACzB,GAAoB,UAAhBxC,EAAOE,KACT,MAAMF,EAAOZ,IAcf,MAXoB,UAAhBY,EAAOE,MACS,aAAhBF,EAAOE,KACTO,KAAKuB,KAAOhC,EAAOZ,IACM,WAAhBY,EAAOE,MAChBO,KAAKmE,KAAOnE,KAAKrB,IAAMY,EAAOZ,IAC9BqB,KAAKtB,OAAS,SACdsB,KAAKuB,KAAO,OACa,WAAhBhC,EAAOE,MAAqBsC,IACrC/B,KAAKuB,KAAOQ,GAGP7C,GAGT0F,OAAQ,SAAS9C,GACf,IAAK,IAAIW,EAAIzC,KAAKgC,WAAWQ,OAAS,EAAGC,GAAK,IAAKA,EAAG,CACpD,IAAId,EAAQ3B,KAAKgC,WAAWS,GAC5B,GAAId,EAAMG,aAAeA,EAGvB,OAFA9B,KAAK2E,SAAShD,EAAMQ,WAAYR,EAAMI,UACtCG,EAAcP,GACPzC,IAKb2F,MAAS,SAASjD,GAChB,IAAK,IAAIa,EAAIzC,KAAKgC,WAAWQ,OAAS,EAAGC,GAAK,IAAKA,EAAG,CACpD,IAAId,EAAQ3B,KAAKgC,WAAWS,GAC5B,GAAId,EAAMC,SAAWA,EAAQ,CAC3B,IAAIrC,EAASoC,EAAMQ,WACnB,GAAoB,UAAhB5C,EAAOE,KAAkB,CAC3B,IAAIqF,EAASvF,EAAOZ,IACpBuD,EAAcP,GAEhB,OAAOmD,GAMX,MAAM,IAAIlG,MAAM,0BAGlBmG,cAAe,SAAS1C,EAAUf,EAAYE,GAa5C,OAZAxB,KAAKjB,SAAW,CACd/B,SAAUoD,EAAOiC,GACjBf,WAAYA,EACZE,QAASA,GAGS,SAAhBxB,KAAKtB,SAGPsB,KAAKrB,SA7rBPE,GAgsBOK,IAQJ3C,GAOsByI,EAAOzI,SAGtC,IACE0I,mBAAqB3I,EACrB,MAAO4I,GAUPC,SAAS,IAAK,yBAAdA,CAAwC7I,gCCxuB7B8I,EAAuBC,kHAQvBC,EAAkBD,oVAsBlBE,EAAmBF,+IAWnBG,EAAsBH,2UAC/BC,EACAC,GCpCSE,EAAwBJ,2TACjCD,EACAG,GAeSG,EAAQL,gTACjBD,EACAI,GAeSG,EAAWN,4NACpBD,GAWSQ,EAAgBP,4MACzBD,GAaSS,GAA0BR,kRACnCD,EACAI,GAcSM,GAAeT,6QACxBD,EACAI,GAeSO,GAA8BV,0UACvCD,GAcSY,GAA+BX,8YACxCD,EACAI,GAkBSS,GAAmBZ,0TAC5BD,GAeSc,GAA6Bb,gYACtCD,EACAI,GAkBSW,GAAwBd,+bACjCD,EACAI,GAsBSY,GAAkBf,4SAC3BD,GAcSiB,GAAuBhB,2PAChCD,GAUSkB,GAAyBjB,uUAClCD,GAkBSmB,GAAelB,sVACxBG,EACAJ,GAeSoB,GAAuBnB,6bAChCG,EACAJ,GAuBSqB,GAAuBpB,mSAChCG,EACAJ,GAaSsB,GAAyBrB,+PAClCD,GAUSuB,GAAiBtB,mPAC1BG,EACAJ,GAaSwB,GAAiBvB,yPAC1BG,EACAJ,GAaSyB,GAA8BxB,kSACvCG,EACAJ,GAaS0B,GAAyBzB,kQAClCG,EACAJ,GAaS2B,GAAyB1B,oUAClCC,EACAE,EACAJ,GAgBS4B,GAAyB3B,uVAClCC,EACAE,EACAJ,GAgBS6B,GAAkB5B,qRAC3BG,EACAJ,GCzZS8B,GADkC,oBAAXC,UACmBA,OAAOC,aCEjDC,GAAuBhC,0KAChCE,GAUS+B,GAAOjC,+JAChBG,GCsKS+B,GAAO,gBACJnL,IAAdoL,aACAC,IAAAA,QAoCMC,6BAA4B,WAAMC,2EAChCC,EAAezL,EAAQ0L,kBAE7B1L,EAAQ2L,QAER1L,EAAO2L,WAAW,CAChBC,MAAOV,GACPW,KAAM,CACJC,gBAAgB,KAIpB9L,EAAO+L,cAEHP,SAAgBD,IAAAA,EAAMS,sCACHhM,EAAOiM,OAG1B,CACAC,SAAUlC,GACVmC,eACKZ,GACHa,SAAUZ,8EAKT,wGAGHa,6BAAgC,WAAMd,kFACpCvL,EAAOiM,OAAoD,CAC/DC,SAAU3C,EACV4C,UAAW,CACTH,WACKT,GACHF,QAAAA,gJA8CFiB,6BAAsC,2FACpCC,EAAQxM,EAAQyM,uCAGdhK,MAAM,4CAGOxC,EAAOiM,OAG1B,CACAC,SAAUxC,GACVyC,UAAW,CAAEI,MAAAA,6BALT5H,UAQMkH,gBAAPY,EAAaC,cAAbC,EAA0BC,SAC7BtB,sBAGK3G,mGAGHkI,6BAA4C,WAAMtB,kFACjCvL,EAAOiM,OAG1B,CACAC,SAAUjC,GACVkC,eAAgBZ,8IAMduB,6BAAwD,WAAMvB,kFAC7CvL,EAAOiM,OAG1B,CACAC,SAAUhC,GACViC,eAAgBZ,GAAMF,QAAAA,qJA2JnB,CACLwB,eAAAA,EACAE,uBA5HgE,SAAAxB,UAChEvL,EAAO2L,WAAW,CAChBC,MAAOV,GACPW,KAAM,CACJC,gBAAgB,KAIb9L,EAAOiM,OAGZ,CACAC,SAAUtC,GACVuC,eACKZ,GAELyB,OAAQ,SAACC,WAAKpB,IAAAA,WACRA,YAAAA,EAAMqB,6BAANC,EAAkCZ,OACpCxM,EAAQqN,gBAAgB7B,EAAKa,UAC7BrM,EAAQsN,UAAU,CAChBC,YAAazB,EAAKqB,2BAA2BX,MAC7CgB,UAAW1B,EAAKqB,2BAA2BK,WAAa,QAG1DvN,EAAO2L,WAAW,CAChBC,MAAOV,GACPW,KAAM,CACJC,gBAAgB,SAkG1B0B,8CAzIwD,WAAMjC,kFACzCvL,EAAOiM,OAG1B,CACAC,SAAUvC,GACVwC,eAAgBZ,8IAoIlBkC,MA3T8B,oBAAGC,eAAAA,gBAA0BnC,2JACrDK,EAAQ8B,EAAiBxC,GAAOD,GAChC0C,EAAgBD,EAAiBpE,EAAQD,SAE/CrJ,EAAO2L,WAAW,CAChBC,MAAAA,EACAC,KAAM,CACJC,gBAAgB,KAIb9L,EAAOiM,OAA8C,CAC1DC,SAAUyB,EACVxB,eACKZ,GAELyB,OAAQ,SAACC,WAAKpB,IAAAA,WACRA,YAAAA,EAAM+B,cAANC,EAAmBtB,MACrBxM,EAAQsN,UAAU,CAChBC,YAAazB,EAAK+B,YAAYrB,MAC9BgB,UAAW1B,EAAK+B,YAAYL,YAG9BvN,EAAO2L,WAAW,CAChBC,MAAAA,EACAC,KAAM,CACJC,gBAAgB,SAkS1BR,OAAAA,EACAwC,qBA7F4D,SAC5DC,YAAAA,IAAAA,GAAc,OAERR,EAAYxN,EAAQiO,eACpBxC,EAAezL,EAAQ0L,sBAExB8B,QACG/K,MAAM,gCAILxC,EAAOiM,OADZ8B,EAIA,CACA7B,SAAUpC,GACVqC,UAAW,CACTC,SAAUZ,EACVQ,MAAOiC,KAAKC,UAAU,CACpBX,UAAAA,KAGJP,OAAQ,SAACC,WAAKpB,IAAAA,WACRA,YAAAA,EAAMsC,kBAANC,EAAuB7B,MACzBxM,EAAQsN,UAAU,CAChBC,YAAazB,EAAKsC,gBAAgB5B,MAClCgB,UAAW1B,EAAKsC,gBAAgBZ,WAAa,OAG/CjC,MASN,CACAY,SAAUrC,GACVsC,UAAW,CACTC,SAAUZ,EACVQ,MAAOiC,KAAKC,UAAU,CACpBX,UAAAA,KAGJP,OAAQ,SAACC,WAAKpB,IAAAA,WACRA,YAAAA,EAAMsC,kBAANE,EAAuB9B,MACzBxM,EAAQsN,UAAU,CAChBC,YAAazB,EAAKsC,gBAAgB5B,MAClCgB,UAAW1B,EAAKsC,gBAAgBZ,WAAa,OAG/CjC,QAyCNgD,aAnP4C,SAACP,YAAAA,IAAAA,GAAc,OACrDR,EAAYxN,EAAQiO,mBAErBT,QACG/K,MAAM,gCAILxC,EAAOiM,OADZ8B,EAIA,CACA7B,SAAUzC,GACV0C,UAAW,CACToB,UAAAA,GAEFP,OAAQ,SAACC,WAAKpB,IAAAA,WACRA,YAAAA,EAAM0C,eAANC,EAAoBjC,MACtBxM,EAAQ0O,eAAe5C,EAAK0C,aAAahC,OAEzCjB,MAMkE,CACxEY,SAAU1C,EACV2C,UAAW,CACToB,UAAAA,GAEFP,OAAQ,SAACC,WAAKpB,IAAAA,WACRA,YAAAA,EAAM0C,eAANG,EAAoBnC,MACtBxM,EAAQ0O,eAAe5C,EAAK0C,aAAahC,OAEzCjB,QAiNNe,SAAAA,EACAS,qBAAAA,EACA6B,YA/J0C,SAAApD,UACnCvL,EAAOiM,OAA0D,CACtEC,SAAU/B,GACVgC,eAAgBZ,GAChByB,OAAQ,SAACC,WAAKpB,IAAAA,WACRA,YAAAA,EAAM8C,cAANC,EAAmBrC,OACrBxM,EAAQsN,UAAU,CAChBC,YAAazB,EAAK8C,YAAYpC,MAC9BgB,UAAW1B,EAAK8C,YAAYpB,WAAa,WAwJjDsB,+CAvC0D,6FACpDtB,EAAYxN,EAAQiO,eACpBxC,EAAezL,EAAQ0L,kBAExB8B,wBACG/K,MAAM,gDAGOxC,EAAOiM,OAG1B,CACAC,SAAUnC,GACVoC,UAAW,CACTC,SAAUZ,EACVQ,MAAOiC,KAAKC,UAAU,CACpBX,UAAAA,+BARA5I,UAaMkH,gBAAPiD,EAAaC,iBAAbC,EAA6BpC,SAChC7M,EAAQ2L,0BAGH/G,mGAeP2H,YAAAA,INzeA2C,GAGO,KAsBEC,GAAc,SAAdA,sBAII,SAHfC,iBAAAA,oBACAC,qBAAAA,aAAuB,UACvBC,sBAAAA,kDACsB,WACtBrD,EACAsD,wGAAAA,IAAAA,EAAoB,IAEftP,wBACG,IAAIwC,MACR,mGAIA+J,EAAQxM,EAAQyM,iBACdhB,EAAezL,EAAQ0L,4BAIzB,CAAC,eAAgB,mBAAmB8D,SAGlCtB,KAAKuB,MAAMF,EAAKG,KAAMrI,YAAYsI,wDAG7BC,EAAM3D,EAAOsD,yEAIpBH,IAAoB5C,sBAEhBqD,EACsD,KAAzDC,EAAoBtD,GAAOuD,IAAMV,cAG9BH,qCACIA,wCACGc,KAAKC,OAASJ,2BAEvBX,GAAiBzD,EACbvL,EAAW6N,uBACX7N,EAAWqO,yBACTW,uFAIRA,GAAiB,0BAEnB1C,EAAQxM,EAAQyM,4BAGdD,IACF+C,EAAKW,aACAX,EAAKW,gCACgB1D,MAIxB8C,IAAyB9C,oCACJoD,EAAM3D,EAAOsD,kBAA9BY,mBAC0BA,EAASC,QAAQC,kBAC3CC,SADAxE,oBACoBA,EAAMyE,eAANC,EAAcC,MACtC,SAAAzL,eAA8C,oCAArCA,EAAM0L,qBAAYzI,UAAU0I,SAEnCC,EAIO,MAEPN,iCAEIpB,qCAC2BA,WAA7B0B,wCAEA1B,GAAiBzD,EACbvL,EAAW6N,uBACX7N,EAAWqO,yBACcW,WAA7B0B,sBAIAA,EAAqB9E,OAtG7BlH,EAuG+BgM,EAAqB9E,KAtGd,oBAAqBlH,YAuG/CgM,EAAqB9E,KAAKsC,wBAA1ByC,EAA2CrE,eAC3CoE,EAAqB9E,gBAArBgF,EAA2BtC,qBAA3BuC,EAAyCvE,iDAGtC2C,EAAY,CACjBC,kBAAkB,EAClBE,uBAAuB,GAFlBH,CAGJlD,EAAOsD,YAIVrP,EAAWqL,6FAIb2D,GAAiB,mDAIdiB,oCAGFP,EAAM3D,EAAOsD,sCA/HS,IAC7B3K,8GAiIIoM,GAAkB,SAACC,SAA2C,CAClEC,MAAO,CACLC,OAAQ,CACNC,cAAe,CACbC,cAAKnE,cACMoE,IADDA,WAEN,MACAC,IAHiBA,aAGL,CACVC,WAAY,YAKpBC,GAAI,CACFJ,cAAKnE,SAAkBwE,IAAAA,QACfC,GAAMJ,IADJA,aACgB,CACtBC,WAAY,gBAGPE,EAAQC,GAAOA,EAAM,OAGhC5F,eAAgB,CACdsF,cACEA,qBAAAA,IAAAA,EAAOJ,KAAejR,EAAQiO,kBAG1BqD,IAFFA,WAEY,kBAIPD,MAKfO,KAAM,CAOJC,UAAW,GACXV,OAAQ,CACNW,UAAW,CACTC,OAAO,OAMFC,GAAqB,SAChCC,EACAhB,EACAiB,OAEMC,EAAWC,iBAAe,CAC9BxC,MAAOT,GAAY+C,GACnBG,IAAKJ,EACLK,YAAa,YAGTC,EAAQ,IAAIC,gBAAc,CAC9BC,aAAczB,GAAgBC,YAGhChR,EAAS,IAAIyS,eAAa,CACxBH,MAAAA,EACAI,KAAMR,IAQRjS,EAAakL,GAAK,CAAEC,aAAcpL,EAAQqL,QAAS,KAE5CrL,GOjOI2S,GAAgBC,EAAMC,cAAmC,MCezDC,GAAc,SACzBlH,UACG,kBApBoB,SACvBzK,OAEM4R,EAAeC,aAAWL,QAE3BI,QACG,IAAIvQ,MACR,iIAKKuQ,EAAa5R,GAQI8R,CAAiBrH,KCdhCsH,GAAUJ,GAAY,QCHtBK,GAAUL,GAAY,QCAtBM,GAAkBN,GAAY,0DJEuB,gBAChE9S,IAAAA,OACAqT,IAAAA,WAE8BT,EAAMU,SAAuBtT,GAApDkC,OAASqR,cAEhBX,EAAMY,WAAU,WACdD,EAAWvT,KACV,CAACA,IAEAkC,EAEA0Q,gBAACD,GAAcc,UAASrS,MAAOc,GAC5BmR,GAKA,sFKlByB,gBAChCrB,IAAAA,WAEAzG,KAAAA,aAAO,KAEHmI,IAHJrI,UAIwCE,EAAhCyF,UAAAA,gBAAkB2C,EAAcpI,EAAdoI,WbEC,SAACC,OACxBpI,EAA8BV,GAC9BE,aAAa6I,QcnBkB,uBdoB/B,KACAvG,EAA6B,KAC7BC,EACFqG,GAAoB9I,GAChBE,aAAa6I,QcvBY,oBdwBzB,KAEAzG,EAAkB,SAAChB,GACnBtB,KACEsB,EACFpB,aAAa8I,Qc9BgB,sBd8Be1H,GAE5CpB,aAAa+I,WchCgB,wBdoCjCvI,EAAeY,GAGX4H,EAAe,SAACzH,GAChBqH,GAAoB9I,KAClByB,EACFvB,aAAa8I,QczCY,mBdyCevH,GAExCvB,aAAa+I,Wc3CY,qBd+C7BxG,EAAYhB,GAERkC,EAAiB,SAAClC,GACtBe,EAAcf,GAwBhBxM,EAAU,CACRqN,gBAAAA,EACAqB,eAAAA,EACAuF,aAAAA,EACAvI,gBAzBsB,kBAAqBD,GA0B3CgB,eAzBqB,kBAAqBc,GA0B1CU,aAzBmB,kBAAqBT,GA0BxCF,UAxBgB,gBAEhBE,IAAAA,UAKAkB,IANAnB,aAOA0G,EAAazG,IAiBb7B,MAdY,WACZ0B,EAAgB,MAChBqB,EAAe,MACfuF,EAAa,QalDfC,CAAcjD,OACR5F,EAAe2G,GAAmBC,EAAQhB,EAAW2C,GACrDO,EAAgB,CAAE9I,aAAAA,EAAcC,QAASqI,GACzCS,EAAUhJ,GAAK+I,GACfE,EEqHY,gBACJpU,IAAdoL,aACAC,IAAAA,QAEMgJ,EAAQlJ,GAAK,CAAEC,aAAcpL,EAAQqL,QAAAA,IAErCiJ,6BAA0C,WAAM/H,wFAC/BvM,EAAOiM,OAG1B,CACAC,SAAU3B,GACV4B,UAAW,CAAEI,MAAAA,mBALT5H,SAQN0P,EAAM/I,2BAEC3G,oGAGH4P,6BAA4D,WAAMC,kFACjDxU,EAAOiM,OAG1B,CACAC,SAAU5B,GACV6B,UAAW,CAAEd,QAAAA,EAASmJ,YAAAA,8IAMpBC,6BAAoD,WAAMlI,kFACzCvM,EAAOiM,OAG1B,CACAC,SAAU7B,GACV8B,UAAW,CAAEd,QAAAA,EAASkB,MAAAA,8IAMpBmI,6BAAoD,WAAMnJ,kFACzCvL,EAAOiM,OAG1B,CACAC,SAAU9B,GACV+B,eAAgBZ,GAAMF,QAASE,EAAKF,SAAWA,+IAM7CsJ,6BAA0C,WAAMpJ,kFAC/BvL,EAAOiM,OAG1B,CACAC,SAAU1B,GACV2B,eAAgBZ,8IAMdqJ,6BAAgE,WAAMrJ,kFACrDvL,EAAOiM,OAG1B,CACAC,SAAUzB,GACV0B,eAAgBZ,oJAsDb,CACL+I,cAAAA,EACAC,uBAAAA,EACAE,mBAAAA,EACAI,gDApD4D,WAAMtJ,kFAC7CvL,EAAOiM,OAG1B,CACAC,SAAUvB,GACVwB,eAAgBZ,8IA+ClBuJ,gDAzC4D,WAAMC,kFAC7C/U,EAAOiM,OAG1B,CACAC,SAAUxB,GACVyB,UAAW,CAAE4I,UAAAA,8IAoCfL,mBAAAA,EACAC,cAAAA,EACAK,gDAhC4D,WAAMzJ,kFAC7CvL,EAAOiM,OAG1B,CACAC,SAAUtB,GACVuB,eAAgBZ,8IA2BlBqJ,yBAAAA,EACAK,0CAtBgD,WAAM1J,kFACjCvL,EAAOiM,OAG1B,CACAC,SAAUrB,GACVsB,eAAgBZ,+IF/OJ2J,CAAKhB,MAEjBlD,EAAW,KACPzD,EAAYxN,EAAQiO,eACpBxC,EAAezL,EAAQ0L,kBAEzB8B,GAAa/B,EACf2I,EAAQrG,sBAAqB,GACpBP,GACT4G,EAAQ7F,cAAa,SAIV,CACbnD,KAAMgJ,EACNe,KAAMd,EACNe,OAAQ,CAAE9J,QAASqI,EAAU0B,WAzBZ,SAAC/J,UAClBqI,EAAWrI,GAwB8B2F,UAAAA,GACzCqE,UAAW,CAAEjK,aAAAA,GACbkK,SAAU,kBGtCU,SACtBtV,UAEAA,EAAOuV,UAAqB,CAC1B3J,MAAOV,KHkCgBoK,CAASlK,8CH3BR,eOK1BQ,EPJQC,GOIRD,EPJiEV,GOdrC,SAC5BU,OAEMmH,EAAeC,aAAWL,QAE3BI,QACG,IAAIvQ,MACR,iIAIGgT,WAA4B5J,EAAO,CACxC5L,OAAQ+S,EAAasC,UAAUjK,aAC/BqK,YAAa,eAOfC,CAAyC9J,IPNjCC,SAEHA,QACG,IAAIrJ,MACR,wEAIGqJ"}